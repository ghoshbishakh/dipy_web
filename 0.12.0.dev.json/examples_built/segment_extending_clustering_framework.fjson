{"page_source_suffix": ".rst", "prev": null, "alabaster_version": "0.7.7", "body": "<div class=\"section\" id=\"enhancing-quickbundles-with-different-metrics-and-features\">\n<span id=\"example-segment-extending-clustering-framework\"></span><h1>Enhancing QuickBundles with different metrics and features<a class=\"headerlink\" href=\"#enhancing-quickbundles-with-different-metrics-and-features\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>QuickBundles is a flexible algorithm that requires only a distance metric and\nan adjacency threshold to perform clustering. There is a wide variety of metrics\nthat could be used to cluster streamlines.</p>\n<p>The purpose of this tutorial is to show how to easily create new <cite>Feature</cite> and\nnew <cite>Metric</cite> classes that can be used by QuickBundles.</p>\n<div class=\"section\" id=\"clustering-framework\">\n<span id=\"id1\"></span><h2>Clustering framework<a class=\"headerlink\" href=\"#clustering-framework\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Dipy provides a simple, flexible and fast framework to do clustering of\nsequential data (e.g. streamlines).</p>\n<p>A <em>sequential datum</em> in Dipy is represented as a numpy array of size\n<span class=\"math\">\\((N \\times D)\\)</span> where each row of the array represents a D dimensional\npoint of the sequence. A set of these sequences is represented as a list of\nnumpy arrays of size <span class=\"math\">\\((N_i \\times D)\\)</span> for <span class=\"math\">\\(i=1:M\\)</span> where <span class=\"math\">\\(M\\)</span> is the\nnumber of sequences in the set.</p>\n<p>This clustering framework is modular and divided in three parts:\n1) feature extraction\n2) distance computation\n3) clustering algorithm</p>\n<p>The <strong>feature extraction</strong> part includes any preprocessing needed to be done on\nthe data before computing distances between them (e.g. resampling the number of\npoints of a streamline). To define a new way of extracting features, one has to\nsubclass <cite>Feature</cite> (see below).</p>\n<p>The <strong>distance computation</strong> part includes any metric capable of evaluating a\ndistance between two set of features previously extracted from the data. To\ndefine a new way of extracting features, one has to subclass <cite>Metric</cite> (see below).</p>\n<p>The <strong>clustering algorithm</strong> part represents the clustering algorithm itself\n(e.g. QuickBundles, K-means, Hierarchical Clustering). More precisely, it\nincludes any algorithms taking as input a list of sequential data and\noutputting a <cite>ClusterMap</cite> object.</p>\n</div>\n<div class=\"section\" id=\"extending-feature\">\n<h2>Extending <cite>Feature</cite><a class=\"headerlink\" href=\"#extending-feature\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new feature extraction\nmethod that can be used in the context of this clustering framework. For a\nlist of available features in Dipy see <a class=\"reference internal\" href=\"../segment_clustering_features/#example-segment-clustering-features\"><span class=\"std std-ref\">Tractography Clustering - Available Features</span></a>.</p>\n<p>Assuming a set of streamlines, the type of features we want to extract is the\narc length (i.e. the sum of the length of each segment for a given streamline).</p>\n<p>Let&#8217;s start by importing the necessary modules.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">Feature</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">length</span>\n</pre></div>\n</div>\n<p>We now define the class &#8216;ArcLengthFeature&#8217; that will perform the desired\nfeature extraction. When subclassing <cite>Feature</cite>, two methods have to be\nredefined: <cite>infer_shape</cite> and <cite>extract</cite>.</p>\n<p>Also, an important property about feature extraction is whether or not\nits process is invariant to the order of the points within a streamline.\nThis is needed as there is no way one can tell which extremity of a\nstreamline is the beginning and which one is the end.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nc\">ArcLengthFeature</span><span class=\"p\">(</span><span class=\"n\">Feature</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Computes the arc length of a streamline. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># The arc length stays the same even if the streamline is reversed.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">__init__</span><span class=\"p\">(</span><span class=\"n\">is_order_invariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">infer_shape</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Infers the shape of features extracted from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># Arc length is a scalar</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">extract</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Extracts features from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># return np.sum(np.sqrt(np.sum((streamline[1:] - streamline[:-1]) ** 2)))</span>\n        <span class=\"c1\"># or use a Dipy&#39;s function that computes the arc length of a streamline.</span>\n        <span class=\"k\">return</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">streamline</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The new feature extraction <cite>ArcLengthFeature</cite> is ready to be used. Let&#8217;s use\nit to cluster a set of streamlines by their arc length. For educational\npurposes we will try to cluster a small streamline bundle known from\nneuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">nibabel</span> <span class=\"k\">import</span> <span class=\"n\">trackvis</span> <span class=\"k\">as</span> <span class=\"n\">tv</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_data</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">fvtk</span>\n\n<span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_data</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">streams</span><span class=\"p\">,</span> <span class=\"n\">hdr</span> <span class=\"o\">=</span> <span class=\"n\">tv</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">)</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">streams</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using the metric <cite>SumPointwiseEuclideanMetric</cite>\nand our <cite>ArcLengthFeature</cite>.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">SumPointwiseEuclideanMetric</span>\n\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">SumPointwiseEuclideanMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">())</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">colormap</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"o\">.</span><span class=\"n\">centroids</span><span class=\"p\">))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">ren</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">ren</span><span class=\"p\">()</span>\n<span class=\"n\">ren</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">n_frames</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_arclength.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id2\">\n<img alt=\"examples_built/fornix_clusters_arclength.png\" src=\"examples_built/fornix_clusters_arclength.png\" />\n<p class=\"caption\"><span class=\"caption-text\"><strong>Showing the different clusters obtained by using the arc length</strong>.</span></p>\n</div>\n</div>\n<div class=\"section\" id=\"extending-metric\">\n<h2>Extending <cite>Metric</cite><a class=\"headerlink\" href=\"#extending-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new metric that can be\nused in the context of this clustering framework. For a list of available\nmetrics in Dipy see <a class=\"reference internal\" href=\"../segment_clustering_metrics/#example-segment-clustering-metrics\"><span class=\"std std-ref\">Tractography Clustering - Available Metrics</span></a>.</p>\n<p>Assuming a set of streamlines, we want a metric that computes the cosine\ndistance giving the vector between endpoints of each streamline (i.e. one\nminus the cosine of the angle between two vectors). For more information\nabout this distance check <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cosine_similarity\">http://en.wikipedia.org/wiki/Cosine_similarity</a>.</p>\n<p>Let&#8217;s start by importing the necessary modules.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">Metric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">VectorOfEndpointsFeature</span>\n</pre></div>\n</div>\n<p>We now define the class <cite>CosineMetric</cite> that will perform the desired\ndistance computation. When subclassing <cite>Metric</cite>, two methods have to be\nredefined: <cite>are_compatible</cite> and <cite>dist</cite>. Moreover, when implementing the\n<cite>dist</cite> method, one needs to make sure the distance returned is symmetric\n(i.e. <cite>dist(A, B) == dist(B, A)</cite>).</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nc\">CosineMetric</span><span class=\"p\">(</span><span class=\"n\">Metric</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Computes the cosine distance between two streamlines. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># For simplicity, features will be the vector between endpoints of a streamline.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">CosineMetric</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">__init__</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">VectorOfEndpointsFeature</span><span class=\"p\">())</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">are_compatible</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">shape1</span><span class=\"p\">,</span> <span class=\"n\">shape2</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Checks if two features are vectors of same dimension.</span>\n\n<span class=\"sd\">        Basically this method exists so we don&#39;t have to do this check</span>\n<span class=\"sd\">        inside the `dist` method (speedup).</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">return</span> <span class=\"n\">shape1</span> <span class=\"o\">==</span> <span class=\"n\">shape2</span> <span class=\"ow\">and</span> <span class=\"n\">shape1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dist</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Computes a the cosine distance between two vectors. &quot;&quot;&quot;</span>\n        <span class=\"n\">norm</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">))</span>\n\n        <span class=\"c1\"># Make sure it&#39;s in [-1, 1], i.e. within domain of arccosine</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">minimum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arccos</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span>  <span class=\"c1\"># Normalized cosine distance</span>\n</pre></div>\n</div>\n<p>The new distance <cite>CosineMetric</cite> is ready to be used. Let&#8217;s use\nit to cluster a set of streamlines according to the cosine distance of the\nvector between their endpoints. For educational purposes we will try to\ncluster a small streamline bundle known from neuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">nibabel</span> <span class=\"k\">import</span> <span class=\"n\">trackvis</span> <span class=\"k\">as</span> <span class=\"n\">tv</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_data</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">fvtk</span>\n\n<span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_data</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">streams</span><span class=\"p\">,</span> <span class=\"n\">hdr</span> <span class=\"o\">=</span> <span class=\"n\">tv</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">)</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">streams</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using our metric <cite>CosineMetric</cite>.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CosineMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">colormap</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">ren</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">ren</span><span class=\"p\">()</span>\n<span class=\"n\">ren</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">n_frames</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_cosine.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id3\">\n<img alt=\"examples_built/fornix_clusters_cosine.png\" src=\"examples_built/fornix_clusters_cosine.png\" />\n<p class=\"caption\"><span class=\"caption-text\"><strong>Showing the different clusters obtained by using the cosine metric</strong>.</span></p>\n</div>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"first admonition-title\">Example source code</p>\n<p class=\"last\">You can download <a class=\"reference download internal\" href=\"../../_downloads/segment_extending_clustering_framework.py\" download=\"\"><code class=\"xref download docutils literal\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>.\nThis same script is also included in the dipy source distribution under the\n<code class=\"file docutils literal\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</div>\n</div>\n", "parents": [], "metatags": "", "title": "Enhancing QuickBundles with different metrics and features", "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Enhancing QuickBundles with different metrics and features</a><ul>\n<li><a class=\"reference internal\" href=\"#clustering-framework\">Clustering framework</a></li>\n<li><a class=\"reference internal\" href=\"#extending-feature\">Extending <cite>Feature</cite></a></li>\n<li><a class=\"reference internal\" href=\"#extending-metric\">Extending <cite>Metric</cite></a></li>\n</ul>\n</li>\n</ul>\n", "current_page_name": "examples_built/segment_extending_clustering_framework", "next": null, "meta": {}, "rellinks": [["genindex", "General Index", "I", "index"]], "display_toc": true, "sourcename": "examples_built/segment_extending_clustering_framework.txt", "customsidebar": null}