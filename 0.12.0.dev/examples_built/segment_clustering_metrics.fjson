{"body": "<div class=\"section\" id=\"tractography-clustering-available-metrics\">\n<span id=\"example-segment-clustering-metrics\"></span><h1>Tractography Clustering - Available Metrics<a class=\"headerlink\" href=\"#tractography-clustering-available-metrics\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>This page lists available metrics that can be used by the tractography\nclustering framework. For every metric a brief description is provided\nexplaining: what it does, when it&#8217;s useful and how to use it. If you are not\nfamiliar with the tractography clustering framework, check this tutorial\n<a class=\"reference internal\" href=\"../segment_extending_clustering_framework/#clustering-framework\"><span class=\"std std-ref\">Clustering framework</span></a>.</p>\n<div class=\"contents local topic\" id=\"available-metrics\">\n<p class=\"topic-title first\">Available Metrics</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"#average-of-pointwise-euclidean-metric\" id=\"id5\">Average of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#sum-of-pointwise-euclidean-metric\" id=\"id6\">Sum of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#minimum-average-direct-flip-metric-mdf\" id=\"id7\">Minimum Average Direct Flip Metric (MDF)</a></li>\n<li><a class=\"reference internal\" href=\"#cosine-metric\" id=\"id8\">Cosine Metric</a></li>\n</ul>\n</div>\n<p><strong>Note</strong>:\nAll examples assume a function <cite>get_streamlines</cite> exists. We defined here a\nsimple function to do so. It imports the necessary modules and load a small\nstreamline bundle.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_streamlines</span><span class=\"p\">():</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">nibabel</span> <span class=\"k\">import</span> <span class=\"n\">trackvis</span> <span class=\"k\">as</span> <span class=\"n\">tv</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_data</span>\n\n    <span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_data</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">streams</span><span class=\"p\">,</span> <span class=\"n\">hdr</span> <span class=\"o\">=</span> <span class=\"n\">tv</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">)</span>\n    <span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">streams</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">streamlines</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"average-of-pointwise-euclidean-metric\">\n<span id=\"clustering-examples-averagepointwiseeuclideanmetric\"></span><h2><a class=\"toc-backref\" href=\"#id5\">Average of Pointwise Euclidean Metric</a><a class=\"headerlink\" href=\"#average-of-pointwise-euclidean-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>AveragePointwiseEuclideanMetric</cite> first compute the\npointwise Euclidean distance between two sequences <em>of same length</em> then\nreturn the average of those distances. This metric takes as inputs two features\nthat are sequences containing the same number of elements.</p>\n<p><strong>When:</strong> By default the <cite>QuickBundles</cite> clustering will resample your\nstreamlines on-the-fly so they have 12 points. If for some reason you want\nto avoid this and you made sure all your streamlines have already the same\nnumber of points, you can manually provide an instance of\n<cite>AveragePointwiseEuclideanMetric</cite> to <cite>QuickBundles</cite>. Since the default\n<cite>Feature</cite> is the <cite>IdentityFeature</cite> the streamlines won&#8217;t be resampled thus\nsaving some computational time.</p>\n<p><strong>Note:</strong> Inputs must be sequences of same length.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">fvtk</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"c1\"># Make sure our streamlines have the same number of points.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the instance of `AveragePointwiseEuclideanMetric` to use.</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Nb. clusters:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cluster sizes:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Nb</span><span class=\"o\">.</span> <span class=\"n\">clusters</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n\n<span class=\"n\">Cluster</span> <span class=\"n\">sizes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">191</span><span class=\"p\">,</span> <span class=\"mi\">44</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"sum-of-pointwise-euclidean-metric\">\n<span id=\"clustering-examples-sumpointwiseeuclideanmetric\"></span><h2><a class=\"toc-backref\" href=\"#id6\">Sum of Pointwise Euclidean Metric</a><a class=\"headerlink\" href=\"#sum-of-pointwise-euclidean-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>SumPointwiseEuclideanMetric</cite> first compute the\npointwise Euclidean distance between two sequences <em>of same length</em> then\nreturn the sum of those distances.</p>\n<p><strong>When:</strong> This metric mainly exists because it is used internally by\n<cite>AveragePointwiseEuclideanMetric</cite>.</p>\n<p><strong>Note:</strong> Inputs must be sequences of same length.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">SumPointwiseEuclideanMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"c1\"># Make sure our streamlines have the same number of points.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"n\">nb_points</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"n\">nb_points</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the instance of `SumPointwiseEuclideanMetric` to use.</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">SumPointwiseEuclideanMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"o\">*</span><span class=\"n\">nb_points</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Nb. clusters:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cluster sizes:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Nb</span><span class=\"o\">.</span> <span class=\"n\">clusters</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n\n<span class=\"n\">Cluster</span> <span class=\"n\">sizes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">191</span><span class=\"p\">,</span> <span class=\"mi\">44</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"minimum-average-direct-flip-metric-mdf\">\n<span id=\"clustering-examples-minimumaveragedirectflipmetric\"></span><h2><a class=\"toc-backref\" href=\"#id7\">Minimum Average Direct Flip Metric (MDF)</a><a class=\"headerlink\" href=\"#minimum-average-direct-flip-metric-mdf\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> It is the metric used in the QuickBundles algorithm <a class=\"reference internal\" href=\"../../reference/dipy.segment/#id23\" id=\"id1\">[Garyfallidis12]</a>.\nInstances of <cite>MinimumAverageDirectFlipMetric</cite> first compute the\ndirect distance <em>d1</em> by taking the average of the pointwise\nEuclidean distances between two sequences <em>of same length</em>. Reverse\none of the two sequences and compute the flip distance <em>d2</em> using the same\napproach as for <em>d1</em>. Then, return the minimum between <em>d1</em> and <em>d2</em>.</p>\n<p><strong>When:</strong> This metric mainly exists because it is used internally by\n<cite>AveragePointwiseEuclideanMetric</cite>.</p>\n<p><strong>Note:</strong> Inputs must be sequences of same length.</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">MinimumAverageDirectFlipMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"c1\"># Make sure our streamlines have the same number of points.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the instance of `MinimumAverageDirectFlipMetric` to use.</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">MinimumAverageDirectFlipMetric</span><span class=\"p\">()</span>\n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">metric</span><span class=\"o\">.</span><span class=\"n\">dist</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">streamlines</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;MDF distance between the first two streamlines: &quot;</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"n\">MDF</span> <span class=\"n\">distance</span> <span class=\"n\">between</span> <span class=\"n\">the</span> <span class=\"n\">first</span> <span class=\"n\">two</span> <span class=\"n\">streamlines</span><span class=\"p\">:</span> <span class=\"mf\">11.681308709622542</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"cosine-metric\">\n<span id=\"id2\"></span><h2><a class=\"toc-backref\" href=\"#id8\">Cosine Metric</a><a class=\"headerlink\" href=\"#cosine-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>CosineMetric</cite> compute the cosine distance between two\nvectors (for more information see the\n<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Cosine_similarity\">wiki page</a>).</p>\n<p><strong>When:</strong> This metric can be useful when you <em>only</em> need information about the\norientation of a streamline.</p>\n<p><strong>Note:</strong> Inputs must be vectors (i.e. 1D array).</p>\n<div class=\"highlight-default\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">fvtk</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">VectorOfEndpointsFeature</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">CosineMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"n\">feature</span> <span class=\"o\">=</span> <span class=\"n\">VectorOfEndpointsFeature</span><span class=\"p\">()</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CosineMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">)</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">colormap</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"c1\"># Visualization</span>\n<span class=\"n\">ren</span> <span class=\"o\">=</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">ren</span><span class=\"p\">()</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">)</span>\n<span class=\"n\">ren</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">fvtk</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">ren</span><span class=\"p\">,</span> <span class=\"n\">n_frames</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;cosine_metric.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id4\">\n<img alt=\"../../_images/cosine_metric.png\" src=\"../../_images/cosine_metric.png\" />\n<p class=\"caption\"><span class=\"caption-text\"><strong>Showing the streamlines colored according to their orientation</strong>.</span></p>\n</div>\n<table class=\"docutils citation\" frame=\"void\" id=\"garyfallidis12\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id1\">[Garyfallidis12]</a></td><td>Garyfallidis E. et al., QuickBundles a method for\ntractography simplification, Frontiers in Neuroscience, vol\n6, no 175, 2012.</td></tr>\n</tbody>\n</table>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"first admonition-title\">Example source code</p>\n<p class=\"last\">You can download <a class=\"reference download internal\" href=\"../../_downloads/segment_clustering_metrics.py\" download=\"\"><code class=\"xref download docutils literal\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>.\nThis same script is also included in the dipy source distribution under the\n<code class=\"file docutils literal\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</div>\n</div>\n", "alabaster_version": "0.7.8", "display_toc": true, "title": "Tractography Clustering - Available Metrics", "sourcename": "examples_built/segment_clustering_metrics.txt", "customsidebar": null, "metatags": "", "current_page_name": "examples_built/segment_clustering_metrics", "next": null, "rellinks": [["genindex", "General Index", "I", "index"], ["np-modindex", "Python Module Index", "", "modules"]], "meta": {}, "parents": [], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Tractography Clustering - Available Metrics</a><ul>\n<li><a class=\"reference internal\" href=\"#average-of-pointwise-euclidean-metric\">Average of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#sum-of-pointwise-euclidean-metric\">Sum of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#minimum-average-direct-flip-metric-mdf\">Minimum Average Direct Flip Metric (MDF)</a></li>\n<li><a class=\"reference internal\" href=\"#cosine-metric\">Cosine Metric</a></li>\n</ul>\n</li>\n</ul>\n", "prev": null, "page_source_suffix": ".rst"}